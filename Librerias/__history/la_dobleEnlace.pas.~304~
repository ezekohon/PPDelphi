unit la_dobleEnlace;


interface

uses
  Winapi.Windows,math,Classes, SysUtils,Graphics, LO_DobleEnlace, Dialogs, lo_hashabierto, LO_ArbolBinario,
  IniFiles, lo_pila, la_arboltrinario,lo_arboltrinario,Rtti,globals;
type
  TArrayMatriz = array[0..4] of tRegCampoMatriz;

function generarGrilla(): tMatriz;
function IsNumberInArray(const ANumber: integer; const AArray: array of tregcampomatriz): boolean;
procedure altaCarton( idJugador: string; nombreEvento:string; grilla: tMatriz);
function isGrillasIguales(grilla1,grilla2: tMatriz):boolean;
function isGrillaEnMe(Var Me:MeDobleEnlace; grilla: tMatriz):boolean;
Procedure OrdenarColumnaGrilla (var V:Array of tRegCampoMatriz);
function getColumnaArreglo(v:tMatriz; index: integer): TArrayMatriz;
procedure ordenarGrilla(var m:tmatriz);
function tieneCartonesComprados(idJugador:tidUsuario; idJuego:tId; var meCartones:MeDobleEnlace):boolean;
function eliminarCartonesDeJugador(idJugador:tidUsuario; idJuego:tId; var meCartones:MeDobleEnlace):integer;
function cantidadCartonesComprados(idJugador:tidUsuario; idJuego:tId; var meCartones:MeDobleEnlace):integer;
function cantidadJugadoresEnJuego(idJuego:tId; var meCartones:MeDobleEnlace):integer;

//PROBAR
function tacharNumeroEnCarton(var carton:tRegDatos_DE; pos:tpos; numeroBolilla: integer):boolean;

function esPremioDiagonal1(grilla: tMatriz):boolean;
function esPremioDiagonal2(grilla: tMatriz):boolean;
function esPremioCruz(grilla: tMatriz):boolean;
function esPremioLineaV(grilla: tMatriz):boolean;
function esPremioLineaH(grilla: tMatriz):boolean;
function esPremioBingo(grilla: tMatriz):boolean;
function esPremioCuadradoChico(grilla: tMatriz):boolean;
function esPremioCuadradoGrande(grilla: tMatriz):boolean;
function esPremioGeneral( grilla: tMatriz; tipoPremio: tTipoPremio):boolean;


implementation

function generarGrilla(): tMatriz;
var
res: tMatriz;
col1,col2,col3,col4,col5: TArrayMatriz;
campo: tRegCampoMatriz;
i,num: integer;
k,h: Integer;
v: TArrayMatriz;
begin
    //Index := RandomRange(1, 6);
    //It may seem a little counter-intuitive, but the lower limit is inclusive, and the upper limit is non-inclusive.
    campo.tachado := false;
    OutputDebugString( pchar('LENGHT '+IntToStr(length(res[0]))));
    for I := 0 to length(res[0])-1 do
    begin
    Randomize;
        num := RandomRange(1,16);
        while IsNumberInArray(num,getColumnaArreglo(res,0)) do
          num := RandomRange(1,16); //no esta comprobando
        campo.numero := num;
        res[i,0]:= campo;

    end;
    for I := 0 to length(res[1])-1 do
    begin
    Randomize;
        num := RandomRange(16,31);
        while IsNumberInArray(num,getColumnaArreglo(res,1)) do
          num := RandomRange(16,31);
        campo.numero := num;
        res[i,1]:= campo;
    end;
    for I := 0 to length(res[2])-1 do
    begin
     //   if i<>2 then
     //   begin
     Randomize;
          num := RandomRange(31,46);
          while IsNumberInArray(num,getColumnaArreglo(res,2)) do
            num := RandomRange(31,46);
          campo.numero := num;
          res[i,2]:= campo;
      //  end
      //  else
     //   begin
      //    begin
      //       campo.numero := 0;
       //      res[i,2]:= campo;
       //   end;
      //  end;
        //insertar 0 en el medio?
    end;
    for I := 0 to length(res[3])-1 do
    begin
    Randomize;
        num := RandomRange(46,61);
        while IsNumberInArray(num,getColumnaArreglo(res,3)) do
          num := RandomRange(46,61);
        campo.numero := num;
        res[i,3]:= campo;
    end;
    for I := 0 to length(res[4])-1 do
    begin
        Randomize;
        num := RandomRange(61,76);
        while IsNumberInArray(num,getColumnaArreglo(res,4)) do
          num := RandomRange(61,76);
        campo.numero := num;
        res[i,4]:= campo;
    end;

    //ordenar
    {for k := 0 to 4 do
    begin
        h:= k;
        v:= getColumnaArreglo(res,h);
        OrdenarColumnaGrilla(v);
    end;
    res[2,2].numero:= 0;   }
    ordenarGrilla(res);

    result := res;
end;


function IsNumberInArray(const ANumber: integer;
  const AArray: array of tregcampomatriz): boolean;
var
  i: integer;
begin
  for i := Low(AArray) to High(AArray) do
    if ANumber = AArray[i].numero then
      Exit(true);
  result := false;
end;

procedure altaCarton( idJugador: string; nombreEvento:string; grilla: tMatriz);
var
reg: tRegDatos_DE;
posicion: tPos;
begin
    reg.idCarton := ObtenerProximoIDInterno(MeCartones);//generarlo
    //reg.idJuego := idJuego;
    reg.nombreEvento:= nombreEvento;
    reg.idJugador := idJugador;
    reg.grilla := grilla;
    BuscarInfo(MeCartones,reg.idCarton,posicion);
    InsertarInfo(MeCartones,reg,posicion);
end;

function isGrillaEnMe(Var Me:MeDobleEnlace; grilla: tMatriz):boolean;
var
  existe: boolean;
  I: Integer;
  reg: tRegDatos_DE;
begin
     //detallar en la documentacion
     i := LO_DobleEnlace.Primero(MeCartones);
     while i <> _posnula do
     begin
         reg:= CapturarInfo(MeCartones, i);
         if isGrillasIguales(grilla, reg.grilla) then
           Exit(true);
         i:= LO_DobleEnlace.Proximo(MeCartones,i);
     end;
     result:= false;
end;

function isGrillasIguales(grilla1,grilla2: tMatriz):boolean;
var
  sonIguales: boolean;
  j, i: Integer;
begin
    for I := 0 to Length(grilla1) do
    begin
      for j := 0 to Length(grilla1[0]) do
      begin
          if grilla1[i,j].numero <> grilla2[i,j].numero then
            Exit(false);
      end;
    end;
    Result:= true;
end;

Procedure OrdenarColumnaGrilla (var V:Array of tRegCampoMatriz);
var
  i: Integer;
  temp: tRegCampoMatriz;
  changed: Boolean;
begin
  changed := True;

  while changed do
  begin
    changed := False;
    for i := Low(V) to High(V)-1 do
    begin
      if (V[i].numero > V[i+1].numero) then
      begin
        temp := V[i+1];
        V[i+1] := V[i];
        V[i] := temp;
        changed := True;
      end;
    end;
  end;
end;


function getColumnaArreglo(v:tMatriz; index: integer): TArrayMatriz;
var
arr: TArrayMatriz;
i: integer;
begin
   for I := 0 to 4 do
   begin
     arr[i]:= v[i,index];
   end;
   result:= arr;
end;

procedure ordenarGrilla(var m:tmatriz);
var
  k,h:integer;
  v:TArrayMatriz;
  I: Integer;
begin
  for k := low(m[0]) to high(m[0])  do
  begin
      h:= k;
      v:= getColumnaArreglo(m,h);
      OrdenarColumnaGrilla(v);
      for I := Low(v) to High(v) do
      begin
          m[i,k]:= v[i];
      end;
  end;
  m[2,2].numero:= 0;
end;

function tieneCartonesComprados(idJugador:tidUsuario; idJuego:tId; var meCartones:MeDobleEnlace):boolean;
//dado id de jugador e id de juego, devolver si el jugador tiene cartones comprados del juego
var
  tiene: boolean;
  j: Integer;
  reg: tRegDatos_DE;
begin
     //detallar en la documentacion
     if not MeVacio(MeCartones) then
     begin
       j := LO_DobleEnlace.Primero(MeCartones);
       //while j <> _posnula do
       repeat

           reg:= LO_DobleEnlace.CapturarInfo(MeCartones, j);


               if ((reg.idJugador= idJugador) and (reg.idJuego = idJuego)) then
                 Exit(true);
               j:= LO_DobleEnlace.Proximo(MeCartones,j);


       until (j = _posnula);
     end;
     result:= false;
end;

function cantidadCartonesComprados(idJugador:tidUsuario; idJuego:tId; var meCartones:MeDobleEnlace):integer;
//dado id de jugador e id de juego, devolver cantidad cartones comprados por el jugador
var
  tiene: boolean;
  j, count: Integer;
  reg: tRegDatos_DE;
begin
    count := 0;
     if not MeVacio(MeCartones) then
     begin
       j := LO_DobleEnlace.Primero(MeCartones);
       //while j <> _posnula do
       repeat
           reg:= LO_DobleEnlace.CapturarInfo(MeCartones, j);
               if ((reg.idJugador= idJugador) and (reg.idJuego = idJuego)) then
                count := count +1;
               j:= LO_DobleEnlace.Proximo(MeCartones,j);
       until (j = _posnula);
     end;
     result:= count;
end;

function cantidadJugadoresEnJuego(idJuego:tId; var meCartones:MeDobleEnlace):integer;
var
  tiene: boolean;
  j,i, count, uniqueCount: Integer;
  reg: tRegDatos_DE;
  arr: array of tidUsuario;
  arrDistinct: THashedStringList;
begin
    count := 0;
     if not MeVacio(MeCartones) then
     begin
       j := LO_DobleEnlace.Primero(MeCartones);
       //while j <> _posnula do
       repeat
           reg:= LO_DobleEnlace.CapturarInfo(MeCartones, j);
               if (reg.idJuego = idJuego) then
               begin
                   SetLength(arr, Length(arr)+1);
                   arr[count]:= reg.idJugador;
                   count := count + 1;
               end;

               j:= LO_DobleEnlace.Proximo(MeCartones,j);
       until (j = _posnula);
     end;

    //VALORES UNICOS
    arrDistinct:= THashedStringList.Create;
      try
      arrDistinct.Sorted := True;
      arrDistinct.Duplicates := dupIgnore; // ignores attempts to add duplicates
      for i := 0 to  High(arr) do
        arrDistinct.Add(arr[i]);
      uniqueCount := arrDistinct.Count;
    finally
      arrDistinct.Free;
    end;
     result:= uniqueCount;
end;

function eliminarCartonesDeJugador(idJugador:tidUsuario; idJuego:tId; var meCartones:MeDobleEnlace):integer;
//elimina y devuelve la cantidad que elimino
var
  j, cant: Integer;
  reg: tRegDatos_DE;
  borro:boolean;
begin
      j := LO_DobleEnlace.Primero(MeCartones);
      cant:=0;
     repeat
        borro:= false  ;
        reg:= CapturarInfo(MeCartones, j);
         if ((reg.idJugador = idJugador) and (reg.idJuego = idJuego)) then
         begin
             Eliminar(MeCartones, j);
             cant:= cant+1;
             borro:= true;
         end;
         if borro then
            j:= LO_DobleEnlace.Primero(MeCartones) //si borro, arranco desde el principio del archivo
         else
            j:= LO_DobleEnlace.Proximo(MeCartones,j);

     until (j = _posnula);

     result:= cant;
end;

function tacharNumeroEnCarton(var carton:tRegDatos_DE; pos: tpos; numeroBolilla: integer):boolean;
var
  i,j:integer;
begin
  //POSIBILIDAD: modificar para que solo traiga el idCarton y buscarlo aca adentro, pero requeriria una busqueda mas
   for I := low(carton.grilla) to high(carton.grilla) do
    begin
      for j := low(carton.grilla[0]) to high(carton.grilla[0]) do
      begin
        if (i<>2) and (j<>2) then
          if (carton.grilla[i,j].numero = numeroBolilla) then
            begin
              carton.grilla[i,j].tachado:= true;
              Modificar(MeCartones, pos, carton);
              Exit(true);
            end;
      end;
    end;
  //si devuelve true, tacho el numero y  modifico en el archivo
  result := false;
end;


//PREMIOS
//tengo q chequear antes de calcularlo, que no se lo di ya en la bolilla anterior
function esPremioDiagonal1(grilla: tMatriz):boolean;
begin
    if grilla[0,0].tachado = true
    and grilla[1,1].tachado = true
    and grilla[3,3].tachado = true
    and grilla[4,4].tachado = true then
      result:= true
      else
      begin
        result:= false;
      end;
end;

function esPremioDiagonal2(grilla: tMatriz):boolean;
begin
     if grilla[0,4].tachado = true
    and grilla[1,3].tachado = true
    and grilla[3,1].tachado = true
    and grilla[4,0].tachado = true then
      result:= true
      else
      begin
        result:= false;
      end;
end;

function esPremioCruz(grilla: tMatriz):boolean;
begin
  if esPremioDiagonal1(grilla) and esPremioDiagonal2(grilla) then
   result:= true
      else
      begin
        result:= false;
      end;
end;

function esPremioLineaH(grilla: tMatriz):boolean;
var
  tieneLinea: boolean;
   i,j:integer;
begin
    tieneLinea:= false;
    for I := low(grilla) to high(grilla) do
    begin
      for j := low(grilla[0]) to high(grilla[0]) do
      begin
        if (i<>2) and (j<>2) then
          if (grilla[i,j].tachado = true) then
                tieneLinea := true
          else
                tieneLinea := false;
      end;
      if tieneLinea then
        Exit(true);
      tieneLinea:= false;
    end;
    result:= false;
end;

function esPremioLineaV(grilla: tMatriz):boolean;
var
  tieneLinea: boolean;
   i,j:integer;
begin
    tieneLinea:= false;
    for I := low(grilla) to high(grilla) do
    begin
      for j := low(grilla[0]) to high(grilla[0]) do
      begin
        if (i<>2) and (j<>2) then
          if (grilla[j,i].tachado = true) then
                tieneLinea := true
          else
                tieneLinea := false;
      end;
      if tieneLinea then
        Exit(true);
      tieneLinea:= false;
    end;
    result:= false;
end;

function esPremioBingo(grilla: tMatriz):boolean;
var
  tieneLinea: boolean;
   i,j:integer;
begin
    tieneLinea:= false;
    for I := low(grilla) to high(grilla) do
    begin
      for j := low(grilla[0]) to high(grilla[0]) do
      begin
        if (i<>2) and (j<>2) then
          if (not grilla[i,j].tachado) then
                Exit(false);
      end;
    end;

    result:= true;
end;

function esPremioCuadradoChico(grilla: tMatriz):boolean;
begin
    if grilla[1,1].tachado
    and grilla[1,2].tachado
    and grilla[1,3].tachado
    and grilla[2,3].tachado
    and grilla[3,3].tachado
    and grilla[3,2].tachado
    and grilla[3,1].tachado
    and grilla[2,1].tachado then
      result:= true
      else
        result:= false
end;

function esPremioCuadradoGrande(grilla: tMatriz):boolean;
begin
    if grilla[0,0].tachado
    and grilla[0,1].tachado
    and grilla[0,2].tachado
    and grilla[0,3].tachado
    and grilla[0,4].tachado
    and grilla[1,4].tachado
    and grilla[2,4].tachado
    and grilla[3,4].tachado
    and grilla[4,4].tachado
    and grilla[4,3].tachado
    and grilla[4,2].tachado
    and grilla[4,1].tachado
    and grilla[4,0].tachado
    and grilla[3,0].tachado
    and grilla[2,0].tachado
    and grilla[1,0].tachado then
          result:= true
        else
          result:= false
end;

function esPremioGeneral( grilla: tMatriz; tipoPremio: tTipoPremio):boolean;
begin
  case tipoPremio of
    Ninguno: result:= false;
    LineaHorizontal: result:= esPremioLineaH(grilla);
    LineaVertical: result:= esPremioLineaV(grilla);
    Diagonal1: result:= esPremioDiagonal1(grilla);
    Diagonal2: result:= esPremioDiagonal2(grilla);
    Cruz: result:= esPremioCruz(grilla);
    CuadradoChico: result:= esPremioCuadradoChico(grilla);
    CuadradoGrande: result:= esPremioCuadradoGrande(grilla);
    Bingo: result:= esPremioBingo(grilla);
  end;
end;

function varificarEInsertarPremios(var carton:tRegDatos_DE; out premio:tTipoPremio):boolean;
var
  claveGanador: string;
  posTri: tPosTri;
  N:tNodoIndiceTri;
  importePremio: real;
  juego: tRegDatosHash;
  i:integer;
  tipoPremio: tTipoPremio;
  posHash: tPosHash;
begin
    claveGanador:= generarClaveGanador(carton.idJugador,carton.nombreEvento);
    //buscar el ganador en el arbol trinario
    BuscarNodo_Tri (meindiceganadores,claveGanador,PosTri);
    ObtenerNodo(MeIndiceGanadores,PosTri,N);
    //TENGO EN N.MH la cabecera de la pila


    //buscar en la pila si ya tiene el tipo de premio p/c uno
        //si no lo tiene ve si ahora si
          //si ahora si: insertar el premio en ganadores y notificar al jugador

    BuscarHash(MeJuego,carton.nombreEvento,posHash);
    CapturarInfoHash(MeJuego,posHash,juego);

    //esto p/c premio
    //for I := TRttiEnumerationType(tipoPremios).MinValue to TRttiEnumerationType(tipoPremios).MaxValue do
    for tipoPremio := Low(ttipopremio) to High(ttipopremio) do
    begin
      //FALTA: IF not PremioYaEntregado pero a todos los jugadores del juego

      if esPremioGeneral(carton.grilla,tipoPremio) then
      begin
          if globals.JugadorLogueado.clave = carton.idJugador then
          begin
              importePremio := la_arboltrinario.importePorTipoPremio(juego,tipoPremio);
              restarPremioAPozoAcumulado(juego,importePremio);
              AltaGanador(claveGanador,tipoPremio,importePremio,carton.idCarton);
          end;
      end;
    end;

    //no iria, itero arriba
   { if not premioYaEntregado(n.hm,tTipoPremio.LineaHorizontal) then
    begin
        if esPremioLineaH(carton.grilla) then
        begin
            if globals.JugadorLogueado.clave = carton.idJugador then
            begin
                 importePremio := la_arboltrinario.importePorTipoPremio(juego,LineaHorizontal);
                 restarPremioAPozoAcumulado(juego,importePremio);
                 AltaGanador(claveGanador,LineaHorizontal,importePremio,carton.idCarton);
            end;

        end;
    end;  }
end;

function mensajeGanadorPremio(premio: tTipoPremio):string;
begin
  result:= 'Useted ha ganado el premio: ' + TRttiEnumerationType.GetName(premio) + '!';
end;


end.
