unit la_dobleEnlace;


interface

uses
  Winapi.Windows,math,Classes, SysUtils,Graphics, LO_DobleEnlace, Dialogs;
type
  TArrayMatriz = array[0..4] of tRegCampoMatriz;

function generarGrilla(): tMatriz;
function IsNumberInArray(const ANumber: integer; const AArray: array of tregcampomatriz): boolean;
procedure altaCarton( idJugador: string; grilla: tMatriz);
function isGrillasIguales(grilla1,grilla2: tMatriz):boolean;
function isGrillaEnMe(Var Me:MeDobleEnlace; grilla: tMatriz):boolean;
Procedure OrdenarColumnaGrilla (var V:Array of tRegCampoMatriz);
function getColumnaArreglo(v:tMatriz; index: integer): TArrayMatriz;
procedure ordenarGrilla(var m:tmatriz);

implementation

function generarGrilla(): tMatriz;
var
res: tMatriz;
col1,col2,col3,col4,col5: TArrayMatriz;
campo: tRegCampoMatriz;
i,num: integer;
k,h: Integer;
v: TArrayMatriz;
begin
    //Index := RandomRange(1, 6);
    //It may seem a little counter-intuitive, but the lower limit is inclusive, and the upper limit is non-inclusive.
    campo.tachado := false;
    OutputDebugString( pchar('LENGHT '+IntToStr(length(res[0]))));
    for I := 0 to length(res[0])-1 do
    begin
        num := RandomRange(1,16);
        while IsNumberInArray(num,getColumnaArreglo(res,0)) do
          num := RandomRange(1,16); //no esta comprobando
        campo.numero := num;
        res[i,0]:= campo;

    end;
    for I := 0 to length(res[1])-1 do
    begin
        num := RandomRange(16,31);
        while IsNumberInArray(num,getColumnaArreglo(res,1)) do
          num := RandomRange(16,31);
        campo.numero := num;
        res[i,1]:= campo;
    end;
    for I := 0 to length(res[2])-1 do
    begin
     //   if i<>2 then
     //   begin
          num := RandomRange(31,46);
          while IsNumberInArray(num,getColumnaArreglo(res,2)) do
            num := RandomRange(31,46);
          campo.numero := num;
          res[i,2]:= campo;
      //  end
      //  else
     //   begin
      //    begin
      //       campo.numero := 0;
       //      res[i,2]:= campo;
       //   end;
      //  end;
        //insertar 0 en el medio?
    end;
    for I := 0 to length(res[3])-1 do
    begin
        num := RandomRange(46,61);
        while IsNumberInArray(num,getColumnaArreglo(res,3)) do
          num := RandomRange(46,61);
        campo.numero := num;
        res[i,3]:= campo;
    end;
    for I := 0 to length(res[4])-1 do
    begin
        num := RandomRange(61,76);
        while IsNumberInArray(num,getColumnaArreglo(res,4)) do
          num := RandomRange(61,76);
        campo.numero := num;
        res[i,4]:= campo;
    end;

    //ordenar
    {for k := 0 to 4 do
    begin
        h:= k;
        v:= getColumnaArreglo(res,h);
        OrdenarColumnaGrilla(v);
    end;
    res[2,2].numero:= 0;   }
    ordenarGrilla(res);

    result := res;
end;


function IsNumberInArray(const ANumber: integer;
  const AArray: array of tregcampomatriz): boolean;
var
  i: integer;
begin
  for i := Low(AArray) to High(AArray) do
    if ANumber = AArray[i].numero then
      Exit(true);
  result := false;
end;

procedure altaCarton( idJugador: string; grilla: tMatriz);
var
reg: tRegDatos_DE;
posicion: tPos;
begin
    reg.idCarton := ObtenerProximoIDInterno(MeCartones);//generarlo
    reg.idJugador := idJugador;
    reg.grilla := grilla;
    BuscarInfo(MeCartones,reg.idCarton,posicion)  ;
    InsertarInfo(MeCartones,reg,posicion);
end;

function isGrillaEnMe(Var Me:MeDobleEnlace; grilla: tMatriz):boolean;
var
  existe: boolean;
  I: Integer;
  reg: tRegDatos_DE;
begin
     //detallar en la documentacion
     i := Primero(MeCartones);
     while i <> _posnula do
     begin
         reg:= CapturarInfo(MeCartones, i);
         if isGrillasIguales(grilla, reg.grilla) then
           Exit(true);
         i:= Proximo(MeCartones,i);
     end;
     result:= false;
end;

function isGrillasIguales(grilla1,grilla2: tMatriz):boolean;
var
  sonIguales: boolean;
  j, i: Integer;
begin
    for I := 0 to Length(grilla1) do
    begin
      for j := 0 to Length(grilla1[0]) do
      begin
          if grilla1[i,j].numero <> grilla2[i,j].numero then
            Exit(false);
      end;
    end;
    Result:= true;
end;

Procedure OrdenarColumnaGrilla (var V:Array of tRegCampoMatriz);
var
  i: Integer;
  temp: tRegCampoMatriz;
  changed: Boolean;
begin
  changed := True;

  while changed do
  begin
    changed := False;
    for i := Low(V) to High(V)-1 do
    begin
      if (V[i].numero > V[i+1].numero) then
      begin
        temp := V[i+1];
        V[i+1] := V[i];
        V[i] := temp;
        changed := True;
      end;
    end;
  end;
end;


function getColumnaArreglo(v:tMatriz; index: integer): TArrayMatriz;
var
arr: TArrayMatriz;
i: integer;
begin
   for I := 0 to 4 do
   begin
     arr[i]:= v[i,index];
   end;
   result:= arr;
end;

procedure ordenarGrilla(var m:tmatriz);
var
  k,h:integer;
  v:TArrayMatriz;
begin
  for k := low(m) to high()-1  do
  begin
      h:= k;
      //v:= getColumnaArreglo(res,h);
      OrdenarColumnaGrilla(getColumnaArreglo(m,h));
  end;
  m[2,2].numero:= 0;
end;

end.
